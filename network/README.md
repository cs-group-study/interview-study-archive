# Network

## ❓TCP와 UDP에 대해 설명해주세요.

TCP는 신뢰적이고 연결지향형 서비스를 제공하는 프로토콜입니다. 프로세스가 다른 프로세스에게 데이터를 보내기 전에 핸드셰이크를 함으로써 연결을 보장하며, 흐름 제어, 혼잡 제어, 오류 제어와 같은 기법으로 데이터의 신뢰적인 전송을 보장합니다.

### 흐름 제어

송신 측과 수신 측의 데이터 처리 속도를 해결하기 위한 기법으로 Stop and Wait, Sliding Window 등이 존재합니다.

- **Stop and Wait**

  매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법입니다.

- **Sliding Window**

  수신 측에서 설정한 윈도우 크기만큼, 송신측에서 확인 응답 없이 패킷을 전송할 수 있게 하여 데이터의 흐름을 동적으로 조절하는 기법입니다.

  송신 측은 윈도우에 포함된 패킷을 계속 전송하며, 이후 스신측으로부터 확인 응답이 오게 되면 윈도우를 옆으로 밀어 다음 패킷들을 전송합니다.

### 혼잡 제어

네트워크의 데이터 처리 속도를 해결하기 위한 기법으로, AIMD, Slow Start, Fast Recovery 등이 있습니다.

- **AIMD**

  패킷을 하나씩 보내고, 문제 없이 도착한다면 윈도우의 크기를 1씩 증가시켜가며 전송하는 방식입니다. 만약 전송에 실패하면 윈도우 크기를 반으로 줄입니다.

- **Slow Start**

  윈도우 크기를 선형적으로 증가시키는 AIMD와 달리, 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식입니다.

- **Fast Recovery**

  혼잡한 상태가 되면, 윈도우 크기를 1로 줄이지 않고 절반으로 줄인 뒤, 선형 증가시키는 방식입니다.
  즉, Slow Start로 윈도우 크기를 증가시키다가 혼잡을 겪으면 이후에는 절반의 윈도우 크기에서 AIMD 방식으로 동작하게 됩니다.

### 오류 제어

데이터가 유실되거나 에러가 발생하였을 때 해결하기 위한 기법으로 Stop and Wait, Go Back N 등이 있습니다.

- **Stop and Wait**

  송신측에서 1개의 데이터를 송신하고, 수신측은 해당 데이터를 정상적으로 받았다면 ACK, 받지 않았다면 NAK를 보내는 방식입니다.
  송신측이 수신측으로부터 ACK를 받았다면 다음 데이터를, NAK나 일정시간 아무런 패킷을 받지 않았다면 데이터를 재전송합니다.

- **Go Back N**

  송신측에서는 여러 데이터를 보낸 후, 전송된 데이터가 분실되거나 타임아웃이 발생한 경우, 마지막으로 확인된 데이터 이후 모든 데이터를 재전송하는 방식입니다.

UDP는 비신뢰적이고 비연결형인 서비스를 제공하는 프로토콜로, 어플리케이션이 허용되는 한, 어떤 속도로든 전송할 수 있습니다. 트랜스포트 계층 프로토콜이 할 수 있는 최소한의 기능으로 동작합니다. 그렇기 때문에 일반적인 상황에서 TCP보다 빠른 속도를 제공할 수 있다는 것이 장점입니다.

## ❓TCP보다 UDP의 속도가 더 빠른 이유는 무엇인가요?

- **연결 설정이 없기 때문입니다.**

  UDP는 TCP의 three-way handshake와 같은 공식적인 사전 준비 없이 전송하기 때문에, 연결을 설정하기 위한 어떤 지연도 없게 되어 속도가 빠릅니다.

- **작은 패킷 헤더 오버헤드를 갖고 있기 때문입니다.**

  TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 8바이트의 오버헤드를 갖기 때문에 빠른 전송이 가능합니다.

- **연결 상태가 없기 때문입니다.**

  UDP는 연결 상태를 유지하지 않으며, 연결 상태에 대한 그 어떠한 파라미터도 기록하지 않는다. 따라서 일반적으로 특정 애플리케이션 전용 서버는, 애플리케이션 프로그램이 UDP에서 동작할 때 좀 더 많은 액티브 클라이언트를 수용할 수 있어 빠른 속도를 보장합니다.

- **혼잡 제어를 하지 않기 때문입니다.**

  만약 TCP를 사용하여 라우터에 패킷 오버플로가 발생하게 되어 높은 손실률이 발생하게 된다면, TCP 송신자는 손실률을 감소시키기 위해 혼잡 제어 기법을 사용하며 데이터 전송 속도를 감소시킵니다. 그렇지만 UDP는 손실률과 상관 없이 데이터를 보내기 때문에 속도가 빠릅니다.

## ❓UDP가 활용되는 분야는 무엇인가요?

실시간으로 데이터를 빠르게 송/수신 해야할 경우 UDP를 활용해야 할 것 같습니다. 실제로 이러한 기능을 제공하는 서비스는 인터넷 전화, 온라인 게임, 멀티미디어 스트리밍 등이 있을 것 같습니다.

이외에도 성능과 연속성이 중요하면서 중요하지 않은 데이터의 손실은 감안할 수 있는 서비스라면 UDP를 활용할 수 있다고 생각합니다.

## ❓HTTP/2.0에 대해 설명해주세요.

HTTP/2는 기존의 HTTP/1.1 에서 존재했던 불편함을 개선하고자 노력을 하였으며 많은 점이 개선되었습니다.

우선 HTTP/2는 SPDY 프로토콜을 기반으로 동작하는데, 이는 기존의 HTTP에서 알려진 성능 제한을 해결하기 위해 웹 페이지의 로드 대기 시간을 줄이는 것을 목표로 구글에서 개반한 프로콜입니다.

- **이진 프로토콜**

  HTTP/1.1은 텍스트 기반 프로토콜이었기 때문에 아스키 코드로 작성되었다. 덕분에 사람이 읽기에는 편하지만 불필요하게 데이터가 커지는 문제가 있었습니다.

  HTTP/2는 보내야 할 데이터를 바이너로 변환하는 계층이 있기 때문에 단순히 텍스트를 전송하는 것 보다 훨씬 더 효율적으로 데이터를 전송할 수 있게 되었습니다.

- **응답 다중화(multiplexing)**

  HTTP/1.1은 TCP 연결에서 한 번에 하나의 요청만 처리 가능하였으나, HTTP/2 에서는 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있도록 개선하였습니다.

  이는 TCP 연결을 스트림, 메시지, 프레임이라는 단위로 세분화했기 때문입니다.

  프레이밍(framing)을 통해 HTTP 메시지를 독립된 프레임들로 쪼개고, 반대편에서 재조립할 수 있게 만들면서 동시에 많은 요청을 처리하게 되었습니다.

- **헤더 필드 압축(HPACK)**

  달라진 부분만 다시 전송하는 허프만 코딩 기법을 사용하여, 불필요하게 발생하는 오버헤드를 최소화 시켰습니다.

이 외에도 클라이언트가 요청하지 않은 리소스를 미리 클라이언트에게 보낼 수 있는 서버 푸시 기능, 스트림별 우선 순위 지정 등이 구현되었습니다.

### HTTP/1.1

기존의 HTTP/1.1은, 지속적인 연결을 사용할 때 웹 페이지당 오직 하나의 TCP 연결을 가집니다. 때문에 한번에 하나의 파일만을 보낼 수 있고, 이러한 특성으로 Head Of Line Blocking 문제가 발생할 수 있습니다.

- **Head Of Line Blocking**

  서버와 클라이언트 사이에 병목 현상이 일어나는 링크가 있다고 가정하고, 큰 비디오 파일과 수많은 작은 파일을 보낸다고 생각 해보겠습니다.

  비디오 파일이 링크를 통과하는데 오랜 시간이 걸리게 되면서, 작은 파일들이 끊임 없이 기다려야 하는 상황이 발생한다. 이런 상황에 비디오 파일이 작은 파일들을 Blocking 합니다.

이러한 문제를 해결하기 위해, HTTP/1.1 은 여러개, 최대 여섯개의 병렬 TCP 연결을 열었습니다.

- **병렬 TCP 연결**

  병렬로 TCP 연결을 하게 되면, 파일이 여러개 있는 페이지의 경우 더 빠르게 다운 받을 수 있습니다. 또한 각 연결의 지연시간을 겹치게 함으로써, 총 지연 시간을 줄일 수 있습니다.

  그렇지만 항상 병렬 TCP 연결이 빠른 것은 아닙니다. 애초에 클라이언트의 네트워크 대역폭이 좁을 경우, 데이터를 전송하고, 내려받는 시간이 느려지기 때문에 성능 상의 장점이 없어집니다.

### HTTP/3.0

HTTP/3은 HTTP/2가 TCP 위에서 동작함으로써 발생하는 근본적인 문제들을 해결하였습니다. TCP는 신뢰성을 지향하기 때문에 데이터 손실이 발생하면 재전송을 하게 되는데, 이런 과정에서 TCP 프로토콜 자체에서 HOL Blocking 문제가 발생하게 되었습니다.

또한 혼잡 제어를 수행하기 위해 전송 속도를 낮은 상태에서 천천히 높이는 방식을 사용하는데, 이는 네트워크 상황이 좋을 때 불필요한 지연을 발생시킵니다.

- **QUIC**

  이러한 문제를 해결하기 위해 QUIC 프로토콜을 도입하였습니다. 이는 TCP의 신뢰성 보장을 위해 제공되는 기능을 UDP를 기반으로 직접 구현하여 성능을 개선한 것입니다.

  UDP는 TCP와 달리 기본적으로 신뢰성을 제공하지 않는데, UDP 프로토콜 자체의 구조가 간단하기 때문에, QUIC는 신뢰성을 보장하기 위해 패킷 재전송, 혼잡 제어, 흐름 제어 기능을 직접 구현하였습니다.

  TCP는 최초 연결 수립시 three-way handshake 과정이 필요하지만, HTTP/3 은 최초 연결 설정에서 연결에 필요한 정보들과 데이터를 함께 전송하여 1 RTT로 시간을 절약합니다. 또한 한 번 성공한 연결은 캐싱해 놓은 후 바로 연결을 수립하여 0 RTT가 가능합니다.

- **연결 다중화**

  HTTP/2 또한 연결 다중화가 지원 되어 여러 스트림이 동시에 지원되지만, TCP 특성상 데이터 손실이 발생하면 HOL Blocking이 발생합니다. 하지만 QUIC 기반은 연결 스트림이 완전히 독립적으로 동작하여, 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않습니다.

- **연결 별 고유 UUID**

  TCP 기반의 통신은 IP 기반으로 식별이 되었기 때문에, Wi-Fi 환경에서 셀룰러 환경으로 이동하는 경우 IP 주소가 변경되기 때문에 연결 재수립과정이 필요합니다. 그렇지만 QUIC은 연결 ID 기반이기 때문에 연결이 그대로 유지됩니다.

## ❓URL, URN, URI에 대해 설명해주세요.

URI는 Uniform Resource Identifier, 통합 자원 식별자의 줄임말로 인터넷의 자원을 식별할 수 있는 문자열을 의미하며, 하위 개념으로 URL과 URN이 있습니다.

URL은 Uniform Resource Locator의 줄임말로 네트워크 상에서 리소스가 위치한 정보를 나타냅니다. URL은 HTTP 프로토콜 뿐만 아니라 FTP, SMTP 등 다른 프로토콜에서도 사용할 수 있습니다.

URN은 Uniform Resource Name의 줄임말로 이름으로 리소스를 특정하는 URI입니다. http와 같은 프로토콜을 제외하고 리소스의 이름을 가리키는데 사용됩니다. 때문에 URN에는 리소스 접근 방법과 웹상의 위치가 표기되지 않으며, 실제 자원을 찾기 위해서는 URN을 URL로 변환하여 이용해야 합니다.

즉, URL은 어떻게 리소스를 얻을 것이고 어디에서 가져와야하는지를 명시하는 URI이고, URN은 리소스를 어떻게 접근할 것인지 명시하지 않고 경로와 리소스 자체를 특정하는 것을 목표로하는 URI입니다.

## ❓URL의 구성 요소에 대해 설명해주세요.

URL은 scheme, host, url-path, query로 나뉘어져 있는데, scheme는 사용할 프로토콜, host는 서버의 호스트명과 포트 번호, path는 서버의 경로에 대한 상세 정보, query는 접근할 대상에 전달하는 추가적인 정보를 나타냅니다.

## ❓URI의 구성 요소 중 어떤 것들이 같아야 같은 출처(same origin)이라고 할 수 있을까요?

scheme, host가 같아야 같은 출처라고 판단할 수 있습니다.

## ❓CORS가 무엇이고 겪어봤다면 어떻게 해결하셨는지 설명해 주세요.
CORS는 Cross Origin Resource Sharing에 약자로, 서로 다른 Origin간의 리소스 교환을 뜻한다.

CORS(Cross-Origin Resource Sharing) 란 웹 브라우저에서 보안 상의 이유로 SOP(Same-Origin Policy) 을 우회하는 방법 중 하나입니다.

여기서 SOP(Same-Origin Policy) 는 동일 출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올수 있지만, 다른 출처(Cross-Origin) 서버에 있는 이미지나 리소스는 상호작용이 불가능하다는 정책입니다. 따라서 다른 도메인에서 오는 리소스에 접근하기 위해서는 브라우저가 이를 허용해야 합니다.

CORS는 이러한 Same-Origin Policy 를 우회하기 위한 방법으로, 서버에서 특정 HTTP 헤더를 설정하여 브라우저에게 다른 도메인에서의 리소스에 대한 접근을 허용하도록 알려줍니다. 이를 통해 클라이언트 측에서 다른 도메인의 리소스에 접근할 수 있습니다.

CORS Error

다른 Origin에서 오는 요청이라면 내가 요청으로 받아온 결과를 믿을만한지 그렇지 않은지 검증하는 과정이 필요하다

브라우저에서는 localhost:8080 서버에서 전달 받은 응답중 헤더에 Access-Control-Allow-Origin 값을 확인하고 이 값에 현재 Origin이 포함되는지 확인한다. 포함되어 있다면 CORS를 수행하고 그렇지 않으면 에러를 낸다. 앞서 사진의 빨간 줄은 Origin에 포함되어 있지 않았기 때문에 브라우저에서 CORS 허용하지 않아 발생한 것이다. Origin이 포함되어 있다면 Method도 확인하고 Content Type도 본다.

cors 에러는 브라우저에서 내뱉는 에러.

**해결방법**
1) Access-Control-Allow-Origin 전체 허용
CORS 에러를 해결하는 방법으로 백엔드에서 모든 주소를 Access-Control-Allow-Origin 로 주면 간단히 해결한다.

→ 보안 문제 때문에 비추천

특정 주소만 허용되도록 함

Access-Control-Allow-Origin:특정주소

2) 프록시 서버 사용하기
브라우저에서 보낸 요청을 프론트엔드에서 받아서 대신 보내는 방법이다.

nextjs의 경우에는 next.config.js 라는 파일을 이용해 상대 주소에 대해서는 미리 요청하는 주소를 바꿔줄 수 있다. 이외에도 nginx를 이용해서 프록시를 대신 구현할 수 있다. react에서도 proxy를 사용해서 해결 할 수 있다.

## ❓프리플라이트란?
"preflighted" request는 "simple requests" 와는 달리, 먼저 OPTIONS 메서드를 통해 다른 도메인의 리소스로 HTTP 요청을 보내 실제 요청이 전송하기에 안전한지 확인합니다. cross-origin 요청은 유저 데이터에 영향을 줄 수 있기 때문에 이와같이 미리 전송(preflighted)합니다.