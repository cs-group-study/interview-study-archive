# Network

## ❓TCP와 UDP에 대해 설명해주세요.

TCP는 신뢰적이고 연결지향형 서비스를 제공하는 프로토콜입니다. 프로세스가 다른 프로세스에게 데이터를 보내기 전에 핸드셰이크를 함으로써 연결을 보장하며, 흐름 제어, 혼잡 제어, 오류 제어와 같은 기법으로 데이터의 신뢰적인 전송을 보장합니다.

### 흐름 제어

송신 측과 수신 측의 데이터 처리 속도를 해결하기 위한 기법으로 Stop and Wait, Sliding Window 등이 존재합니다.

- **Stop and Wait**

  매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법입니다.

- **Sliding Window**

  수신 측에서 설정한 윈도우 크기만큼, 송신측에서 확인 응답 없이 패킷을 전송할 수 있게 하여 데이터의 흐름을 동적으로 조절하는 기법입니다.

  송신 측은 윈도우에 포함된 패킷을 계속 전송하며, 이후 스신측으로부터 확인 응답이 오게 되면 윈도우를 옆으로 밀어 다음 패킷들을 전송합니다.

### 혼잡 제어

네트워크의 데이터 처리 속도를 해결하기 위한 기법으로, AIMD, Slow Start, Fast Recovery 등이 있습니다.

- **AIMD**

  패킷을 하나씩 보내고, 문제 없이 도착한다면 윈도우의 크기를 1씩 증가시켜가며 전송하는 방식입니다. 만약 전송에 실패하면 윈도우 크기를 반으로 줄입니다.

- **Slow Start**

  윈도우 크기를 선형적으로 증가시키는 AIMD와 달리, 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식입니다.

- **Fast Recovery**

  혼잡한 상태가 되면, 윈도우 크기를 1로 줄이지 않고 절반으로 줄인 뒤, 선형 증가시키는 방식입니다.
  즉, Slow Start로 윈도우 크기를 증가시키다가 혼잡을 겪으면 이후에는 절반의 윈도우 크기에서 AIMD 방식으로 동작하게 됩니다.

### 오류 제어

데이터가 유실되거나 에러가 발생하였을 때 해결하기 위한 기법으로 Stop and Wait, Go Back N 등이 있습니다.

- **Stop and Wait**

  송신측에서 1개의 데이터를 송신하고, 수신측은 해당 데이터를 정상적으로 받았다면 ACK, 받지 않았다면 NAK를 보내는 방식입니다.
  송신측이 수신측으로부터 ACK를 받았다면 다음 데이터를, NAK나 일정시간 아무런 패킷을 받지 않았다면 데이터를 재전송합니다.

- **Go Back N**

  송신측에서는 여러 데이터를 보낸 후, 전송된 데이터가 분실되거나 타임아웃이 발생한 경우, 마지막으로 확인된 데이터 이후 모든 데이터를 재전송하는 방식입니다.

UDP는 비신뢰적이고 비연결형인 서비스를 제공하는 프로토콜로, 어플리케이션이 허용되는 한, 어떤 속도로든 전송할 수 있습니다. 트랜스포트 계층 프로토콜이 할 수 있는 최소한의 기능으로 동작합니다. 그렇기 때문에 일반적인 상황에서 TCP보다 빠른 속도를 제공할 수 있다는 것이 장점입니다.

## ❓TCP보다 UDP의 속도가 더 빠른 이유는 무엇인가요?

- **연결 설정이 없기 때문입니다.**

  UDP는 TCP의 three-way handshake와 같은 공식적인 사전 준비 없이 전송하기 때문에, 연결을 설정하기 위한 어떤 지연도 없게 되어 속도가 빠릅니다.

- **작은 패킷 헤더 오버헤드를 갖고 있기 때문입니다.**

  TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 8바이트의 오버헤드를 갖기 때문에 빠른 전송이 가능합니다.

- **연결 상태가 없기 때문입니다.**

  UDP는 연결 상태를 유지하지 않으며, 연결 상태에 대한 그 어떠한 파라미터도 기록하지 않는다. 따라서 일반적으로 특정 애플리케이션 전용 서버는, 애플리케이션 프로그램이 UDP에서 동작할 때 좀 더 많은 액티브 클라이언트를 수용할 수 있어 빠른 속도를 보장합니다.

- **혼잡 제어를 하지 않기 때문입니다.**

  만약 TCP를 사용하여 라우터에 패킷 오버플로가 발생하게 되어 높은 손실률이 발생하게 된다면, TCP 송신자는 손실률을 감소시키기 위해 혼잡 제어 기법을 사용하며 데이터 전송 속도를 감소시킵니다. 그렇지만 UDP는 손실률과 상관 없이 데이터를 보내기 때문에 속도가 빠릅니다.

## ❓UDP가 활용되는 분야는 무엇인가요?

실시간으로 데이터를 빠르게 송/수신 해야할 경우 UDP를 활용해야 할 것 같습니다. 실제로 이러한 기능을 제공하는 서비스는 인터넷 전화, 온라인 게임, 멀티미디어 스트리밍 등이 있을 것 같습니다.

이외에도 성능과 연속성이 중요하면서 중요하지 않은 데이터의 손실은 감안할 수 있는 서비스라면 UDP를 활용할 수 있다고 생각합니다.

## ❓HTTP/2.0에 대해 설명해주세요.

HTTP/2는 기존의 HTTP/1.1 에서 존재했던 불편함을 개선하고자 노력을 하였으며 많은 점이 개선되었습니다.

우선 HTTP/2는 SPDY 프로토콜을 기반으로 동작하는데, 이는 기존의 HTTP에서 알려진 성능 제한을 해결하기 위해 웹 페이지의 로드 대기 시간을 줄이는 것을 목표로 구글에서 개반한 프로콜입니다.

- **이진 프로토콜**

  HTTP/1.1은 텍스트 기반 프로토콜이었기 때문에 아스키 코드로 작성되었다. 덕분에 사람이 읽기에는 편하지만 불필요하게 데이터가 커지는 문제가 있었습니다.

  HTTP/2는 보내야 할 데이터를 바이너로 변환하는 계층이 있기 때문에 단순히 텍스트를 전송하는 것 보다 훨씬 더 효율적으로 데이터를 전송할 수 있게 되었습니다.

- **응답 다중화(multiplexing)**

  HTTP/1.1은 TCP 연결에서 한 번에 하나의 요청만 처리 가능하였으나, HTTP/2 에서는 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있도록 개선하였습니다.

  이는 TCP 연결을 스트림, 메시지, 프레임이라는 단위로 세분화했기 때문입니다.

  프레이밍(framing)을 통해 HTTP 메시지를 독립된 프레임들로 쪼개고, 반대편에서 재조립할 수 있게 만들면서 동시에 많은 요청을 처리하게 되었습니다.

- **헤더 필드 압축(HPACK)**

  달라진 부분만 다시 전송하는 허프만 코딩 기법을 사용하여, 불필요하게 발생하는 오버헤드를 최소화 시켰습니다.

이 외에도 클라이언트가 요청하지 않은 리소스를 미리 클라이언트에게 보낼 수 있는 서버 푸시 기능, 스트림별 우선 순위 지정 등이 구현되었습니다.

### HTTP/1.1

기존의 HTTP/1.1은, 지속적인 연결을 사용할 때 웹 페이지당 오직 하나의 TCP 연결을 가집니다. 때문에 한번에 하나의 파일만을 보낼 수 있고, 이러한 특성으로 Head Of Line Blocking 문제가 발생할 수 있습니다.

- **Head Of Line Blocking**

  서버와 클라이언트 사이에 병목 현상이 일어나는 링크가 있다고 가정하고, 큰 비디오 파일과 수많은 작은 파일을 보낸다고 생각 해보겠습니다.

  비디오 파일이 링크를 통과하는데 오랜 시간이 걸리게 되면서, 작은 파일들이 끊임 없이 기다려야 하는 상황이 발생한다. 이런 상황에 비디오 파일이 작은 파일들을 Blocking 합니다.

이러한 문제를 해결하기 위해, HTTP/1.1 은 여러개, 최대 여섯개의 병렬 TCP 연결을 열었습니다.

- **병렬 TCP 연결**

  병렬로 TCP 연결을 하게 되면, 파일이 여러개 있는 페이지의 경우 더 빠르게 다운 받을 수 있습니다. 또한 각 연결의 지연시간을 겹치게 함으로써, 총 지연 시간을 줄일 수 있습니다.

  그렇지만 항상 병렬 TCP 연결이 빠른 것은 아닙니다. 애초에 클라이언트의 네트워크 대역폭이 좁을 경우, 데이터를 전송하고, 내려받는 시간이 느려지기 때문에 성능 상의 장점이 없어집니다.

### HTTP/3.0

HTTP/3은 HTTP/2가 TCP 위에서 동작함으로써 발생하는 근본적인 문제들을 해결하였습니다. TCP는 신뢰성을 지향하기 때문에 데이터 손실이 발생하면 재전송을 하게 되는데, 이런 과정에서 TCP 프로토콜 자체에서 HOL Blocking 문제가 발생하게 되었습니다.

또한 혼잡 제어를 수행하기 위해 전송 속도를 낮은 상태에서 천천히 높이는 방식을 사용하는데, 이는 네트워크 상황이 좋을 때 불필요한 지연을 발생시킵니다.

- **QUIC**

  이러한 문제를 해결하기 위해 QUIC 프로토콜을 도입하였습니다. 이는 TCP의 신뢰성 보장을 위해 제공되는 기능을 UDP를 기반으로 직접 구현하여 성능을 개선한 것입니다.

  UDP는 TCP와 달리 기본적으로 신뢰성을 제공하지 않는데, UDP 프로토콜 자체의 구조가 간단하기 때문에, QUIC는 신뢰성을 보장하기 위해 패킷 재전송, 혼잡 제어, 흐름 제어 기능을 직접 구현하였습니다.

  TCP는 최초 연결 수립시 three-way handshake 과정이 필요하지만, HTTP/3 은 최초 연결 설정에서 연결에 필요한 정보들과 데이터를 함께 전송하여 1 RTT로 시간을 절약합니다. 또한 한 번 성공한 연결은 캐싱해 놓은 후 바로 연결을 수립하여 0 RTT가 가능합니다.

- **연결 다중화**

  HTTP/2 또한 연결 다중화가 지원 되어 여러 스트림이 동시에 지원되지만, TCP 특성상 데이터 손실이 발생하면 HOL Blocking이 발생합니다. 하지만 QUIC 기반은 연결 스트림이 완전히 독립적으로 동작하여, 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않습니다.

- **연결 별 고유 UUID**

  TCP 기반의 통신은 IP 기반으로 식별이 되었기 때문에, Wi-Fi 환경에서 셀룰러 환경으로 이동하는 경우 IP 주소가 변경되기 때문에 연결 재수립과정이 필요합니다. 그렇지만 QUIC은 연결 ID 기반이기 때문에 연결이 그대로 유지됩니다.

## ❓URL, URN, URI에 대해 설명해주세요.

URI는 Uniform Resource Identifier, 통합 자원 식별자의 줄임말로 인터넷의 자원을 식별할 수 있는 문자열을 의미하며, 하위 개념으로 URL과 URN이 있습니다.

URL은 Uniform Resource Locator의 줄임말로 네트워크 상에서 리소스가 위치한 정보를 나타냅니다. URL은 HTTP 프로토콜 뿐만 아니라 FTP, SMTP 등 다른 프로토콜에서도 사용할 수 있습니다.

URN은 Uniform Resource Name의 줄임말로 이름으로 리소스를 특정하는 URI입니다. http와 같은 프로토콜을 제외하고 리소스의 이름을 가리키는데 사용됩니다. 때문에 URN에는 리소스 접근 방법과 웹상의 위치가 표기되지 않으며, 실제 자원을 찾기 위해서는 URN을 URL로 변환하여 이용해야 합니다.

즉, URL은 어떻게 리소스를 얻을 것이고 어디에서 가져와야하는지를 명시하는 URI이고, URN은 리소스를 어떻게 접근할 것인지 명시하지 않고 경로와 리소스 자체를 특정하는 것을 목표로하는 URI입니다.

## ❓URL의 구성 요소에 대해 설명해주세요.

URL은 scheme, host, url-path, query로 나뉘어져 있는데, scheme는 사용할 프로토콜, host는 서버의 호스트명과 포트 번호, path는 서버의 경로에 대한 상세 정보, query는 접근할 대상에 전달하는 추가적인 정보를 나타냅니다.

## ❓URI의 구성 요소 중 어떤 것들이 같아야 같은 출처(same origin)이라고 할 수 있을까요?

scheme, host가 같아야 같은 출처라고 판단할 수 있습니다.

## ❓CORS가 무엇이고 겪어봤다면 어떻게 해결하셨는지 설명해 주세요.

CORS는 Cross Origin Resource Sharing에 약자로, 서로 다른 Origin간의 리소스 교환을 뜻한다.

CORS(Cross-Origin Resource Sharing) 란 웹 브라우저에서 보안 상의 이유로 SOP(Same-Origin Policy) 을 우회하는 방법 중 하나입니다.

여기서 SOP(Same-Origin Policy) 는 동일 출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올수 있지만, 다른 출처(Cross-Origin) 서버에 있는 이미지나 리소스는 상호작용이 불가능하다는 정책입니다. 따라서 다른 도메인에서 오는 리소스에 접근하기 위해서는 브라우저가 이를 허용해야 합니다.

CORS는 이러한 Same-Origin Policy 를 우회하기 위한 방법으로, 서버에서 특정 HTTP 헤더를 설정하여 브라우저에게 다른 도메인에서의 리소스에 대한 접근을 허용하도록 알려줍니다. 이를 통해 클라이언트 측에서 다른 도메인의 리소스에 접근할 수 있습니다.

CORS Error

다른 Origin에서 오는 요청이라면 내가 요청으로 받아온 결과를 믿을만한지 그렇지 않은지 검증하는 과정이 필요하다

브라우저에서는 localhost:8080 서버에서 전달 받은 응답중 헤더에 Access-Control-Allow-Origin 값을 확인하고 이 값에 현재 Origin이 포함되는지 확인한다. 포함되어 있다면 CORS를 수행하고 그렇지 않으면 에러를 낸다. 앞서 사진의 빨간 줄은 Origin에 포함되어 있지 않았기 때문에 브라우저에서 CORS 허용하지 않아 발생한 것이다. Origin이 포함되어 있다면 Method도 확인하고 Content Type도 본다.

cors 에러는 브라우저에서 내뱉는 에러.

**해결방법**

1. Access-Control-Allow-Origin 전체 허용
   CORS 에러를 해결하는 방법으로 백엔드에서 모든 주소를 Access-Control-Allow-Origin 로 주면 간단히 해결한다.

→ 보안 문제 때문에 비추천

특정 주소만 허용되도록 함

Access-Control-Allow-Origin:특정주소

2. 프록시 서버 사용하기
   브라우저에서 보낸 요청을 프론트엔드에서 받아서 대신 보내는 방법이다.

nextjs의 경우에는 next.config.js 라는 파일을 이용해 상대 주소에 대해서는 미리 요청하는 주소를 바꿔줄 수 있다. 이외에도 nginx를 이용해서 프록시를 대신 구현할 수 있다. react에서도 proxy를 사용해서 해결 할 수 있다.

## ❓프리플라이트란?

"preflighted" request는 "simple requests" 와는 달리, 먼저 OPTIONS 메서드를 통해 다른 도메인의 리소스로 HTTP 요청을 보내 실제 요청이 전송하기에 안전한지 확인합니다. cross-origin 요청은 유저 데이터에 영향을 줄 수 있기 때문에 이와같이 미리 전송(preflighted)합니다.

## ❓HTTP 헤더의 종류에 대해 설명해 주세요.

### General Header

공통 헤더는 요청 및 응답의 메시지 모두에서 사용되지만 **컨텐츠에는 적용되지 않는 헤더**입니다.

- Date: 요청 또는 응답이 만들어진 날짜와 시간
- Connection :현재의 전송이 완료된 후 네트워크 접속의 유지 여부
  - Keep-alive : 지속 연결
  - close : 연결 종료
- Cache-Control: 캐시 제어

### Request Header

요청 헤더는 HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더입니다. 보통 Fetch될 리소스나 클라이언트 자체에 대한 정보를 포함하여 서버로 보내집니다.

- Host: 서버의 도메인 네임과 서버가 현재 Listening 중인 TCP 포트를 알려줍니다.
- User-Agent: 사용자가 어떤 클라이언트(운영체제와 브라우저를 포함한)를 이용해 요청을 보냈는지 알려줍니다.
- Accept: 클라이언트가 받을 수 있는 응답의 타입을 서버에게 알려줍니다.
- Authorization: 서버에 인가된 사용자임을 증명할 때 사용합니다. 보통 JWT나 Bearer 토큰을 서버로 보낼 때 사용합니다.
- Origin: POST와 같은 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 알려줍니다.
- Referer

### Response Header

위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더입니다.

- Access-Control-Allow-Origin: 요청이 허용된 origin을 명시, `*`는 아무한테나 받음
- Allow
- Content-Disposition
- Location: 리다이렉트 헤더라고도 하며, 300번대 응답일 때 어느 페이지로 이동할지를 알려줍니다.
- Content-Security-Policy

### Entity Header

컨텐츠 길이나 MIME 타입과 같이 Entity Body에 대한 자세한 정보를 포함하는 헤더입니다.

- Content-Length: 바이트 단위를 가지는 Header + Body의 크기
- Content-Type: 개체의 미디어 타입(MIME)과 문자열 인코딩(UTF-8)을 지정합니다.
- Content-Language: 사용자들에게 언어를 설명하기 위해 사용됩니다. 사용자가 선호하는 언어에 따라 사용자를 구분할 수 있게 합니다.
- Content-Encoding: 미디어 타입을 압축하기 위해서 사용됩니다. ex) gzip, deflate

## ❓아래의 헤더를 통해 알 수 있는 정보는 무엇이 있을까요?

<image src='../images/response-header.png'>

- `Cache-Control`
  - no-store: 응답의 일부라도 캐싱해서는 안 되며 다른 요청을 충족하기 위해 해당 응답을 사용해서는 안 된다는 것을 나타냅니다.
  - no-cache: 유효성 검사를 통과하지 않았다면 다른 요청을 충족하는 데 해당 응답을 사용해서는 안 됨을 나타냅니다.
  - must-revalidate: 응답이 stale해지면 오리진에서 성공적으로 유효성을 검사할 때까지 캐시가 다른 요청을 충족하기 위해 해당 응답을 재사용하지 않아야 함을 나타냅니다.
  - post-check=0: 캐시된 복사본을 사용하고 0초 후 서버에서 유효성 검사를 다시 수행해야 합니다.
  - pre-check=0: 캐시된 복사본을 사용하기 0초 전 서버에서 유효성 검사를 다시 수행해야 합니다.
- `Content-Encoding`
  - gzip: 콘텐트가 gzip으로 인코딩되었음을 나타냅니다.
- `Content-Language`
  - ko-KR: 콘텐트가 한국어 사용자를 대상으로 함을 나타냅니다.
- `Content-Type`
  - text/html;charset=UTF-8: 응답 내용의 미디어 유형을 정의합니다. 여기에서는 UTF-8 문자 인코딩을 사용한 HTML입니다.
- `Date`
  - Wed, 13 Sep 2023 05:31:46 GMT: 응답이 생성된 날짜와 시간을 나타냅니다.
- `Expires`
  - Thu, 19 Nov 1981 08:52:00 GMT: 응답이 stale로 취급받아 캐싱되지 않도록 하기 위해 만료일시를 과거의 날짜로 지정했습니다.
- `Pragma`
  - no-cache: HTTP/1.0 클라이언트에 대한 이전 버전과의 호환성을 제공하고 요청-응답 체인의 모든 캐싱 메커니즘이 준수해야 하는 지시문을 지정합니다.
- `Server`
  - hide: 요청을 처리하는 서버 소프트웨어에 대한 정보를 숨깁니다.
- `Strict-Transport-Security`
  - max-age=0: 중간자 공격으로부터 웹사이트를 보호하는 데 도움이 됩니다. 이 헤더는 브라우저에 항상 HTTPS를 통해 사이트에 연결하도록 지시합니다.
- `Vary`
  - Accept-Encoding: 동일한 리소스의 여러 representation 중에서 선택하는 데 사용된 요청 헤더가 `Accept-Encoding`임을 나타냅니다.
- `X-Content-Type-Options`
  - nosniff: MIME 유형 스니핑 취약성을 완화하는 데 도움이 됩니다. 브라우저에 응답에 지정된 Content-Type을 재정의하지 않도록 지시합니다.
- `X-Frame-Options`
  - "allow-from tistory.com": 클릭재킹 방지 기능을 제공합니다. 이 경우 "tistory.com" 도메인의 콘텐츠에 대해서만 프레이밍을 허용합니다.
- `X-Ua-Compatible`
  - IE=Edge: 브라우저에 특정 버전의 Internet Explorer 렌더링 엔진을 사용하도록 지시합니다.
- `X-Xss-Protection`
  - 1: 브라우저에 내장된 크로스 사이트 스크립팅(XSS) 보호 기능을 활성화합니다.

## ❓REST API에 대해 설명해주세요.

REST는 리소스를 표현하고 상태를 전달하는 방법을 기술한 웹 아키텍처 디자인 패턴입니다.
REST API를 통해 주소와 메서드만 보고 요청의 의도를 파악할 수 있어 개발작간의 소통이 용이해졌다.
RESTful API는 이러한 REST 원칙을 따르며, HTTP 프로토콜을 통해 데이터를 요청, 생성, 수정, 삭제하는 데 사용됩니다

### RESTful API 설계시 규칙

REST는 리소스(자원)를 표현하고 상태를 전달하는 방법이므로, API설계 시 아래 두 가지 규칙을 지키면 좋다.

1. URI는 자원만을 표현하고 동사보다는 명사로 작성할 것. 단수 보다는 복수로.

- 회원 -> `/members`

  1-1. 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용

  - 동물 -> `/animals/mammals/lions`

2. 행위는 아래 HTTP 메서드로만 표시할 것.

- URI에는 행위는 표시하지 않음. 등록 -> `POST`

**HTTP 메서드 (HTTP Methods)**
REST API에서는 HTTP 메서드를 사용하여 리소스를 다룹니다. 주요 HTTP 메서드는 다음과 같습니다.

- **GET:** 리소스를 조회하기 위해 사용됩니다.
- **POST:** 새로운 리소스를 생성하기 위해 사용됩니다.
- **PATCH:** 기존 리소스의 일부를 업데이트하기 위해 사용됩니다.
- **PUT:** 기존 리소스를 업데이트하기 위해 사용됩니다.
- **DELETE:** 리소스를 삭제하기 위해 사용됩니다.

### PUT과 PATCH의 차이점

- **PATCH:** 기존 리소스의 일부를 업데이트하기 위해 사용됩니다.
- **PUT:** 기존 리소스를 업데이트하기 위해 사용됩니다. 리소스를 없으면 새로 생성하고 있다면 대체한다. 쉽게 얘기하면 덮어버린다.

예시를 들면, 사용자의 정보(이름과 나이)를 바꾼다면, PUT의 경우 `{"username": "John", "age": 12}` 를 하여 리소스 전체를 대체한다. 비록 이전의 age가 12이더라도 전체를 업데이트해줘야 하기 때문에 age도 값을 넣어주어야 한다. 만약 이름만 바꾸려고 `{"username": "John"}` 이렇게 리소스를 설정한다면 리소스를 대체하기 때문에 age의 필드는 삭제된다. 이런 경우 리소스의 일부만을 업데이트하는 PATCH를 사용하는 것이 좋다.

리소스가 있는 경우 대체한다고 하였는데, POST와의 차이점은 완전히 대체하는 것이고 PUT은 클라이언트가 리소스를 식별하고 리소스 위치를 알고 URI를 지정한다. 그러나 POST는 서버에서 리소스의 위치를 알지 못한다.

### HTTP 주요 상태코드

**200**

GET: 리소스를 불러와서 메시지 바디에 전송되었습니다.
HEAD: 개체 해더가 메시지 바디에 있습니다.
PUT or POST: 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다.

**201: created**

리소스 생성에 성공한 응답 코드
일반적으로 Post, Put 요청 이후에 사용

**202: Accepted**

요청은 접수가 되었으나 처리가 완료되지 않음

- 배치처리 같은 곳에 사용
- ex) 요청 접수 후 1시간 뒤에 배치 프로세스 요청을 처리함

**204: No Content**

서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음

- 웹) 문서 편집기에서 save 버튼
- save 버튼의 결과로 아무 내용이 없어도 된다.
- save 버튼을 눌러도 같은 화면을 유지해야 한다.
- 결과 내용이 없더라도 204 메세지 만으로도 성공을 인식할 수 있다.

**400: Bad Request**

클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음

- 요청 구문, 메세지 등 오류
- 클라이언트 요청 내용을 다시 검토하고 보내야 함

**401: unauthorized**

- 인증되지 않은 사용자

**403: forbidden**

- 클라이언트가 접근할 권리 없음. 미승인
- ex) 어드민 등급이 아닌 사용자가 로그인을 했지만, 어드민 등급의 리소스에 접근하는 경우

**404: Not Found**

- 요청 리소스가 서버에 없음
- 요청 페이지가 없음
- 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을

(큰 그림)
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)

[출처 MDN] https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

## ❓DNS look-up 과정에 대해 설명해 주세요.

DNS lookup이란 특정 도메인(www.google.com)의 IP 주소(58.230.87.22)를 알아내는 과정입니다. 브라우저의 주소창에 `www.goole.com`을 입력하고 엔터를 치면

1. 브라우저는 브라우저의 캐시에 해당 도메인의 IP 주소가 있는지 확인하고 없다면 OS의 캐시를 확인합니다. 그래도 없다면 DNS Resolver에 물어보는데, 이때 DNS Resolver란 SKT, KT, LG와 같은 ISP(Internet Service Provider)나 Cloudflare(1.1.1.1), Amazon(8.8.8.8)과 같은 DNS Provider를 말합니다.
2. DNS Resolver는 캐시에 해당 도메인의 IP 주소가 있는지 확인한 뒤, 있다면 응답합니다.
3. 캐시에 없다면 DNS Resolver는 먼저 루트 네임서버에 물어보고
4. 루트 네임 서버는 `.com` 네임서버의 IP 주소를 알려줍니다.
5. `.com` 네임서버에 `www.google.com`의 IP주소를 물어보고
6. `.com` 네임서버는 `google.com` 네임서버의 IP 주소를 알려줍니다.
7. `google.com` 네임서버에 `www.google.com`의 IP 주소를 물어보고
8. `google.com` 네임서버는 해당 IP 주소를 응답합니다.
9. DNS Resolver는 이렇게 알아낸 IP 주소를 브라우저에게 알려줍니다.

<image src='../images/dns-lookup.png' />

위 과정에서 브라우저가 DNS Resolver에 물어보는 과정을 `recursive 쿼리`, DNS Resolver가 네임서버에 물어보는 과정을 `iterative 쿼리`라고 합니다.

## ❓프록시(Proxy)에 대해 설명해주세요.

**개념**

프록시란 인터넷과 관련되어 쓰이는경우 컴퓨터 네트워크에서 중간 매개 역할을 하는 시스템 또는 라우터입니다.
클라이언트와 웹 서버 중간에 위치하여 통신을 중개하는 역할을 하며, 프록시 서버는 기본적으로 자체 IP 주소를 가지고 있는 인터넷 상의 컴퓨터입니다.

### 프록시 서버의 용도

1. 익명성 보호
   프록시를 사용하여 Client의 실제 IP 주소를 숨기고 프록시 서버의 IP 주소를 사용하여 웹서버나 다른 리소스에 접근할 수 있습니다. 이를 통해 온라인 익명성을 유지하거나 지역 제한된 콘텐츠에 접근할 수 있습니다.
2. 보안
   클라이언트와 서버 사이의 트래픽을 중개하여, 악의적인 트래픽을 필터링하고 보안 검사를 수행할 수 있습니다. 이를 통해 웹 칠터링을 통해 특정 웹 사이트에 접근을 제한할 수 있습니다.
3. 캐시
   프록시는 이전에 요청한 데이터를 저장하여 동일한 요청이 다시 들어올 때 서버로부터 데이터를 다시 가져오지 않고 저장된 데이터를 반환하여 네트워크 대역폭을 절약하고 응답 시간을 개선할 수 있습니다.
4. 접근 제어
   네트워크 접근을 제어하여 특정 웹사이트나 서버에 대한 접근을 허용/차단 할 수 있습니다. 예로 기업 네트웨크에서 특정 웹사이트를 차단하거나, 부서별로 접근을 제한하는 데에 사용할 수 있습니다.
5. 로깅과 모니터링
   로깅과 모니터링: 프록시는 클라이언트와 서버 간의 모든 트래픽을 기록하고 모니터링할 수 있으므로 네트워크 활동을 추적하고 분석하는 데 도움을 줍니다.

### Forward Proxy (정방향 프록시)와 Reverse Proxy (역방향 프록시)

프록시의 종류는 Forward Proxy, Reverse Proxy, Transparent Proxy, Anonymous Proxy, High Anonymity Proxy 등 많은 종류가 있으며
그 중에서 Forward Proxy와 Reverse Proxy에 대해 알아보겠습니다.

- Forward Proxy (정방향 프록시)
  정방향 프록시는 Client 앞에 위치하며, 내부 네트워크 내의 사용자 그룹에 데이터를 가져오는 데 사용됩니다. 요청이 전송되면 프록시 서버는 요청을 검사하여 연결을 계속 할 지 여부를 결정합니다.

  <image style="max-width:500px;" src='../images/forward-proxy.png' />

- Reverse Proxy (역방향 프록시)
  포워드 프록스(정방향 프록시)와 달리 리버스 프록시는 웹 서버 앞에 위치라여 브라우저의 요청을 웹서버로 전달합니다.
  이는 웹 서버의 네트워크 가장자리에서 사용자의 요청을 가로채는 방식으로 작동합니다. 그런 다음 원본 서버에 요청을 보내고 응답을 받습니다.

  <image style="max-width:500px;" src='../images/reverse-proxy.png' />

## ❓IPv4와 IPv6에 대해 설명해주세요.

IPv4와 IPv6는 모두 IP주소 프로토콜입니다.
이 두 프로토콜은 인터넷에서 기기 간 통신을 가능하게 하는 주소 체계를 정의합니다.
IPv6는 IPv4를 대체하기 위한 것이지만, 현재는 두 가지를 병행하며 사용되고있습니다.

**1. 주소 형식 / 표기법**

- IPv4 주소는 4개의 8비트 숫자로 나타내며, 각 숫자는 점으로 구분됩니다.
- ex) 192.168.1.1

- IPv6 주소는 8개의 16진수 블록으로 표시되며, 각 블록은 콜론으로 구분됩니다.
- ex) 2001:0db8:85a3:0000:0000:8a2e:0370:7334

**2. 보안 및 기타 기능**

- IPv6는 IPv4보다 더 많은 보안 및 기능적인 향상을 제공합니다.

**3. 네트워트**

- IPv4은 현재까지 많은 네트워크에서 사용 중이며, IPv4와 IPv6 간의 호환성을 제공하는 장치와 프로토콜이 있습니다.
- IPv6은 미래를 위한 대안으로 사용되며, 점차 채택이 확대되고 있지만 아직 모든 네트워크와 장치에서 일반적으로 사용되지는 않습니다.

**4. 속도**

- 이론적으로는 IPv6가 더 빠릅니다. 하지만 IPv6가 사용하는 더 큰 패킷 사이즈 때문에 일부 사용 사례에서는 더 느릴 수 있습니다.

**5. 라우팅**

- IPv4 헤더는 길이가 가변적이지만 IPv6에는 일관된 헤더가 있습니다. 즉, 이러한 주소로 라우팅하기 위한 코드가 더 간단해지고 하드웨어 처리도 덜 필요합니다.

## ❓CDN이란 무엇인가요?

CDN은 "콘텐츠 전송 네트워크" 또는 "콘텐츠 배달 네트워크" (Content Delivery Network)의 약자입니다. CDN은 웹 콘텐츠를 더 빠르게 전달하고 사용자에게 최적의 성능을 제공하기 위한 분산 네트워크 시스템입니다.
CDN의 주요 목적은 웹 페이지, 이미지, 동영상, 스크립트 및 기타 웹 리소스를 **전 세계의 사용자에게 빠르게 전송**하는 것입니다.

<image src='../images/cdn.png' />

### 특징

**1. 지역 캐싱:** CDN은 원본 서버에서 콘텐츠를 가져와 여러 지역의 데이터 센터에 복사하고 저장합니다. 이러한 지역 데이터 센터는 사용자와 더 가까워서 콘텐츠를 빠르게 전송할 수 있습니다.

**2. 로드 밸런싱:** CDN은 트래픽을 여러 데이터 센터로 분산하여 서버 부하를 분산하고 성능을 향상시킵니다. 이로 인해 웹 사이트나 애플리케이션의 응답 시간이 단축됩니다.

**3. 캐시 관리:** CDN은 콘텐츠를 캐시로 저장하고, 사용자의 요청에 따라 최적의 캐시된 버전을 제공합니다. 이는 동일한 콘텐츠에 대한 다수의 요청을 처리할 때 특히 효과적입니다.

**4. 보안 및 DDoS 방어:** 분산 서비스 거부(DDoS) 공격은 대량의 가짜 트래픽을 웹 사이트로 전송하여 애플리케이션이 작동 중지되도록 만들려고 시도합니다. CDN은 여러 중간 서버 간에 로드를 분산하여 오리진 서버에 미치는 영향을 줄임으로써 이러한 트래픽 급증을 처리할 수 있습니다.

### 예시

- Amazon CloudFront, Cloudflare, Akamai, Fastly

[이미지 출처]https://www.cloudflare.com/ko-kr/learning/cdn/what-is-caching/

## ❓로드밸런싱에 대해 설명해주세요.

로드 밸런싱이란 서버에 들어오는 네트워크 트래픽 부하(Load)를 백엔드 서버 그룹에 효율적으로 분산(Balancing)하는 것을 의미한다.
<image src="../images/load-balancing.png" style="max-width:500px;"/>

### 기능

- 여러 서버에 걸쳐 클라이언트 요청이나 네트워크 로드를 효율적으로 분산
- 온라인 상태인 서버에만 요청을 보내 고가용성과 안정성을 보장
- 수요에 따라 서버를 추가하거나 빼는 유연성 제공
- 보안 계층을 추가할 수 있는 기능 내장으로 어플리케이션 보안
- 응답 시간을 늘리고 네트워크 지연 시간을 줄려 어플레케이션 성능 향상

### 로드 밸런싱 알고리즘

로드 밸런싱 알고리즘은 로드 밸런서가 서로 다른 클라이언트 요청 각각에 가장 적합한 서버를 결정하기 위해 따르는 규칙 세트입니다. 로드 밸런싱 알고리즘은 크게 2가지 범주로 나뉨니다.

**정적 로드 밸런싱**: 정적 로드 밸런싱 알고리즘은 고정된 규칙을 따르며 현재 서버 상태와 무관합니다.

- 라운드 로빈 방식
- 가중 기반 라운드 로빈 방식
- IP 해시 방식

  **동적 로드 밸런식**: 동적 로드 밸런싱 알고리즘은 트래픽을 배포하기 전에 서버의 현재 상태를 검사합니다.

- 최소 연결 방식
- 가중치 기반 최소 연결 방식
- 최소 응답 시간 방식
- 리소스 기반 방식

[출처 AWS] https://aws.amazon.com/ko/what-is/load-balancing/
[출처 nginx] https://www.nginx.com/resources/glossary/load-balancing/

# ❓NAT(Network Address Translation)에 대해 설명해주세요

- NAT(Network Address Translation)패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 ip주소를 수정하여 ip주소를 다른주소로 매핑하는 방법.ipv4주소 체계만으로는 많은 주소들을 감당하지 못하는 단점이 있는데, 이를 해결하기위해 NAT로 공인ip 와 사설ip로 나눠서 많은 주소를 처리.

- **공인 IP는 한정되어있기 때문에, 사설 IP의 개념이 필요하게 되었고, 공인IP를 가지고 있는 공유기 , 기계를 통해서 사설IP를 할당해준 다음 사설 IP를 가지고 외부의 네트워크와 통신할 때 필요한 기술**이다.

ex) 공유기(공인IP) 와이파이(사설IP)에 접속해서 인터넷(공인IP)을 한다.
요약하면 여러 대의 호스트가 하나의 공인 IP주소를 사용하여 인터넷에 접속하기 위한 경우이다.
다만 단점은 사설IP의 개념 자체가 중복되는 IP가 엄청 많기 때문에, 외부에서 사설 IP로 접근할 수 없다.
=> 이를 보안하기 위해서 나온 개념이 Port Forwarding이다

## 포트 포워딩

- Port Forwarding: NAT기술의 응용 으로서, 패킷이 라우터나 방화벽과 같은 네트워크 장비를 가로지르는 동안 특정 ip주소와 포트 번호의 통신 요청을 특정 다른 IP와 포트번호로 넘겨주는 이 기법은 게이트웨이의 반대쪽에 위치한 사설 네트워크에 상주하는 호스트에 대한 서비스를 생성하기 위해 흔히 사용된다.
- 사설 IP의 단점은 IP를 알아볼 수 없기 때문에, 요청을 보내고 싶어도 보낼 수 없다는 단점이 있다. 따라서 클라이언트가 먼저 요청을 보내는데 이때 서버의 사설 IP로 직접 요청을 보내는 것이 아니라 공인 IP로 요청을 보낸다. 그리고 이 공유기의 포트 포워딩 설정을 하면 특정 포트로 들어온 요청을 다른 특정 사설 IP의 특정 포트로 전송한다.
  이때 포트번호는 포트포워딩을 하는 사용자의 마음대로 설정할 수 있다.

## NAT의 종류?

### 1. Full Cone NAT

가장 간단한 NAT 방식이다.
private ip/port와 public ip/port가 매핑되면, 누구든 간에 그 public ip/port로 접근 시, host에게 통신을 시도할 수 있는 방식
Host의 Private IP와 Port가 Router나 L3 Switch를 통해 Public IP와 Port로 매핑이 되면,
매핑된 정보를 토대로 Host가 Service A로 통신을 시도했을때, Service A도 마찬가지로 매핑된 정보를 토대로 Host에게 패킷을 보낼 수 있고, 이는 Router 또는 L3 Switch를 통해 Host에게 전달이 가능

### 2. Restricted Cone NAT

Full Cone NAT에 비해 통신이 제한되는 부분이 있다
기존에 통신하던 Service의 IP가 아니라면 Host에게로 패킷이 도달하지 않는다

### 3. Port Restricted Cone NAT

Port Restricted Cone은 여기에 host와 통신을 하던 Service의 Server IP, Port가 전부 동일하지 않다면, Host로의 패킷 전달을 차단한다
즉, 기존에 통신하던 Service가 아니면 Host에게 패킷을 직접적으로 보낼 수 없는 환경.

### 4. Symmetric NAT

Symmetric 방식은 통신하는 Service의 IP/Port 를 기반으로, 매핑정보를 달리한다.
Host가 통신하는 대상에 따라 각각 다른 매핑정보를 가져간다. 매핑정보가 계속해서 변하는 방식

https://tomatohj.tistory.com/42

## ❓JWT 토큰, 세션 방식에 대해 설명해 주세요.

JWT는 JSON Web Token의 약자로 JSON 형식의 웹에서 사용되는 토큰을 말하고, Session은
서버 측에서 상태 정보를 유지하는 것으로 둘 다 사용자의 인증/인가 처리를 위해 클라이언트와 서버 사이에서 정보를 주고 받는데 사용됩니다.

### JWT 구조

JWT은 헤더, 페이로드, 서명 으로 `.` 기호를 통해 구분된다.

`<헤더>.<페이로드>.<서명>`

헤더(header) : 토큰의 유형과 서명 알고리즘

페이로드(payload) : 실제로 전송하려는 데이터를 포함, 사용자의 인증/인가 정보

서명(signature) : 헤더와 페이로드가 비밀키로 서명되어 저장되고 토큰이 변조되었는지 여부를 확인하는 데 사용

### JWT의 사용

JWT는 토큰 자체에 정보를 저장하여 session의 데이터를 저장 관리에 의한 서버의 부담을 해결해줍니다.
보통 클라이언트가 어떤 서비스의 인가 서버를 통해 로그인에 성공하면 JWT 토큰을 획득할 수 있는데요. 그러면 클라이언트는 해당 서비스의 API를 호출할 때 JWT 토큰을 보내서 원하는 자원에 접근하거나 허용된 작업을 수행할 수 있게됩니다.
단점으로는 발행된 토큰에 대해 서버는 제어할 수 없어 탈취 당했을 때 보안에 취약하다는 단점이 있어 이를 해결하고자, accessToken, refreshToken을 같이 사용하는 방식을 통해 대비할 수 있습니다.

### Session 방식

서버 기반 인증에서 사용자가 로그인을 성공하면 서버에서 사용자에 대한 세션을 생선합니다. 또한 사용자의 브라우저에는 세션 ID를 저장하는 쿠키가 생성됩니다. 서버는 세션 ID를 통해 사용자를 식별하고 사용자에 대한 정보를 저장, 관리합니다.
