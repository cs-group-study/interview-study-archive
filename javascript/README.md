# JavaScript

## ❓호이스팅에 대해 설명해 주세요.

### 호이스팅

- 호이스트는 “끌어올린다”라는 뜻입니다. 자바스크립트 코드가 실행될 때 하단에 선언된 변수나 함수가 마치 끌어올려져서 처음부터 상단에 존재했던 것처럼 동작해서 붙여진 이름입니다. 실행 컨텍스트의 생성 단계일 때, 식별자들을 환경 레코드에 미리 기록해놓기 때문에 실행 단계에서 미리 접근할 수 있게 되는 것입니다.

- 호이스팅은 Javascript에서 변수 및 함수의 선언이 스코프의 최상단으로 끌어올려지는 동작을 말합니다. 이로 인해 변수와 함수를 선언하기 전에 사용할 수 있는 것처럼 동작합니다.

- 자바스크립트는 코드를 실행하기 전에 먼저 변수와 함수를 메모리(물리적인 장소x, 논리적인 동작)에 올려놓는데, 이때 선언 부분이 코드 내에서 어디에 위치하든지에 관계없이 해당 스코프의 최상단으로 끌여올려집니다. 하지만 선언만 끌어올려지며, 초기화는 원래 위치엣 이루어집니다.

호이스팅의 예시)

```
// var로 선언된 변수
console.log(myVar); // undefined
var myVar = 10;

// 함수 선언식
myFunction(); // "Hello, world!"
function myFunction() {
  console.log("Hello, world!");
}

// 함수 표현식
myFunction1(); // TypeError: myFunction1 is not a function
var myFunction1 = function() {
  console.log("Hello, world!");
};
```

위의 코드는 사실 아래와 같이 해석됩니다.

```
var myVar;
console.log(myVar); // undefined
myVar = 10;

function myFunction() {
  console.log("Hello, world!");
}

myFunction(); // "Hello, world!"
```

### var/let/const 차이점

let과 const는 "블록 스코프(block-scope)"를 가지기 떄문에 호이스팅이 발생해도 실제로 초기화 되기 전까지 "일시적 사각지대(Temporal Dead Zone: TDZ)"에 빠지게 됩니다.
이는 변수가 선언된 위치에서 해당 변수에 접근할 수 없는 상태를 말합니다.

- 중복 선언 가능: var
- 재할당 가능: var, let
- 중복 선언 불가능: let, const

## ❓환경 레코드란 무엇인가요?

함수가 실행되면 실행 컨텍스트가 생성되는데, 실행 컨텍스트의 구성요소 중 식별자들을 기록해 놓는 곳이 환경 레코드입니다.

## ❓클로저에 대해 설명해주세요.

- 클로저는 자바스크립트 뿐만이 아니라 함수형 프로그래밍 언어에서 흔히 사용되는 개념으로, 함수와 해당 함수가 선언된 렉시컬 환경(Lexical Environment) 사이의 관계를 나타냅니다. 내부 함수가 유효한 상태에서 외부 함수가 종료되어 외부 함수의 실행 컨텍스트가 반환되어도, 외부 함수 실행 컨텍스트 내의 변수는 내부 함수에 의해 참조되는 한 유효하여, 내부 함수가 스코프 체인을 통해 참조할 수 있다는 것을 의미합니다.

- 즉, 외부 함수가 이미 반환되었어도, 외부 함수 내의 변수는 이를 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지되고, 실제 변수에 접근 할 수 있습니다.

## ❓스코프 체인에 대해 설명해 주세요.

- 스코프(scope)는 식별자에 대한 유효 범위를 뜻하며, 스코프 체인(scope chain)은 식별자의 유효 범위를 안에서부터 바깥으로 차례대로 검색해 나가는 것을 말합니다.

- 이를 가능하게 하는 것이 outerEnvironmentReference인데, outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조합니다. 이는 연결 리스트의 형태를 띠며, 선언 시점의 LexicalEnvironment를 계속 찾아 올라가면 마지막에 전역 건텍스트의 LexicalEnvironment가 있습니다.

- 이러한 구조적 특성때문에, 가장 가까운 요소부터 차례대로만 접근할 수 있고, 다른 순서로 접근하는 것이 불가능합니다. 즉, 여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능합니다.

## ❓클로저를 직접적으로 활용한 사례나 알고있는게 있다면 설명해주세요.

간단한 예를 들어보자면, DOM 요소의 표시 상태를 토글을 통해 변환시키는 함수를 작성할 때, 해당 토글 함수에, 표시 상태를 나타내는 변수를 선언, 이후 해당 변수를 토글 시키는 클로저를 반환함으로써 표시 상태를 나타내는 변수를 숨기면서도, 최신 상태를 계속 유지하고, 변경될 수 있게 할 수 있습니다.

이렇게 전역변수를 사용하지 않고도, 최신 상태를 유지하고 변경또한 가능하게 하면서 코드의 의도되지 않은 변경을 예방할 수 있습니다.

실제로 리액트의 useState 또한 클로저를 통해 구현되어 있습니다. useState는 state, setState를 반환하게 되는데 해당 setState가 실행될 때 이전 상태와 현재 상태의 변경을 감지해야 하고, 그러기 위해 이전 상태를 가지고 있어야 하는데 이 곳에서 클로저가 활용됩니다.

```javascript
const useState = (value) => {
  let saveValue = value;

  const state = () => saveValue;

  const setState = (newValue) => {
    saveValue = newValue;
  };

  return [state, setState];
};
```
