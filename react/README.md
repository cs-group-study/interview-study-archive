# React

## ❓useState가 어떻게 동작하는지 설명해 주세요.

### React의 state가 상태를 기억하는 방법

React에서 상태(State) 관리는 javascript의 클로저 개념을 활용한 패턴 중 하나입니다.
React의 컴포넌트는 useState hook을 이용해 상태관리를 합니다. useState Hook은 클로저를 이용하여 동작하며, 이를 통해 각 컴포넌트 인스턴스마다 독립적인 상태를 가질 수 있습니다.

한 컴포넌트가 있다고 가정했을 때, 컴포넌트가 렌더링 될 때마다 '함수형 컴포넌트' 함수가 호출되지만, 해당 함수(컴포넌트) 내에서 선언된 변수들은 클로저를 통해 이전 값이 유지되고 상태 관리가 가능해집니다.
따라서 React의 상태관리는 내부적으로 클로저를 활용한 컴포넌트 간 상태를 격리하고 관리하는 기능을 제공합니다.

\*클로저: 클로저란 함수와 그 함수가 선언되었을 때 Lexical Scope 사이의 관계를 나타내는 개념. 클로저를 사용하면 함수 내부에서 외부 스코프의 변수에 접근할 수 있다.

## ❓리액트에서 Hook은 무엇인가요? 어떤 리액트 hook을 쓰고 있나요?

React 라이브러리에서 함수 컴포넌트 내에서 상태 관리와 다양한 기능을 사용하기 위한 방식입니다.
React Hook은 크게 내장 Hook과 커스텀 훅을 만들어 사용하는 두 가지 방법이 있습니다.

## ❓React hooks의 장점은 무엇인가요?

React Hooks는 함수형 컴포넌트에서 상태와 생명주기 기능을 관리하기 위한 기능으로 도입한 것인데, 효율적이고 유연한 개발을 할 수 있게 해줍니다.

- 가독성과 간결성 향상
  - Hooks를 사용하면 Class형 컴포넌트에서 사용되던 복잡한 구조와 문법을 피할 수 있습니다.
- 성능 최적화
  - Hooks는 리액트 내부에서 최적화가 더 잘 이루어질 수 있도록 도와줍니다. 예를 들어 **`useMemo`**와 **`useCallback`**은 불필요한 렌더링을 방지하고 성능을 향상시킬 수 있습니다.
- 테스트 용이성
  - 함수형 컴포넌트와 Hooks를 사용하면 단위 테스트 작성이 더 쉬워집니다. Hooks를 이용하여 컴포넌트의 로직을 테스트하기가 더 간단하고 직관적입니다.

### 커스텀 훅

커스텀 훅을 만들어 사용하는 주요 이점 중 하나는 **로직의 분리와 추상화**입니다. (\*추상화란 복잡한 시스템으로부터 핵심적인 개념또는 기능을 간추려내는 것을 의미) UI와 상태(state)를 분리하여 커스텀 훅으로 감싸면, 컴포넌트 코드는 더 간결해지고 가독성이 높아집니다. 또한 같은 로직을 여러 컴포넌트에서 사용할 때 중복을 피하고 일관성 있게 코드를 작성할 수 있습니다.

## ❓lazy initialization(게으른 초기화)에 대해 설명해 주세요.

useState에 직접적인 값 대신에 함수를 넘기는 것을 게으른(lazy) 초기화라고 합니다. 게으른 초기화 함수는 state가 처음 만들어 질 때만 실행되고 나중에 다시 리렌더링이 된다면 이 함수의 실행은 무시됩니다. 상태의 초깃값을 localStorage에서 가져오거나 map, filter, find 등 복잡한 연산으로 구해야 하는 경우에 사용합니다.

## ❓코드 스플리팅과 게으른 초기화에는 어떤 차이점이 있나요?

둘 다 최적화 기법이지만 사용법과 사용목적이 다릅니다. 코드 스플리팅은 `React.lazy(() => import('컴포넌트 경로'))`를 사용해 지금 당장 필요하지 않은 컴포넌트를 번들에 포함시키지 않고 필요한 시점에 로드하는 기법입니다. 게으른 초기화는 상태의 초깃값으로 함수를 넘겨서 상태의 최초 생성 시점에 한 번만 생성하는 기법입니다.

## ❓useLayoutEffect에 대해 설명해 주세요.

`useEffect`와 `useLayoutEffect`는 비슷하지만 실행 시점이 다릅니다. `useEffect`는 레이아웃과 페인트 이후에 실행되고 `useLayoutEffect`는 DOM이 업데이트 된 뒤에 실행됩니다. 따라서, `useEffect`를 사용하면 시각적인 깜빡임이 발생할 수 있습니다. 하지만, `useLayoutEffect`를 사용하면 화면이 그려지기 전에 작업이 처리되기 때문에, 이러한 깜빡임을 방지할 수 있습니다.

`useLayoutEffect`는

1. DOM 노드에 대한 작업이 필요한 경우
2. 브라우저의 렌더링이 완료되기 전에 작업이 처리되어야 하는 경우
3. 시각적인 깜빡임을 방지해야 하는 경우에 유용합니다.

다만, `useLayoutEffect`는 화면이 그려지기 전에 실행되기 때문에, 작업의 처리 시간이 매우 긴 경우, 사용자가 빈화면을 오랫동안 보게될 수 있으므로 주의해야 합니다.

## ❓useMemo, useCallback에 대해 설명해 주세요.

- `useMemo`는 비용이 높은 연산의 결괏값를 캐시하고, 의존성이 변경될 때만 다시 연산해서 성능을 향상시키는 데 사용됩니다. 특히 계산량이 크거나 렌더링 중에 자주 호출되는 계산의 경우에 유용합니다.
- `useCallback`은 주로 함수의 참조 안정성을 위해 사용됩니다. 함수를 컴포넌트 내에서 만들면, 해당 컴포넌트가 리렌더링될 때마다 새로운 함수가 생성되어서 참조값이 달라집니다. 이 때 `useCallback`을 사용하면 이전에 생성된 함수의 참조값을 재사용할 수 있습니다.

## ❓부모 컴포넌트에서 React.memo를 적용한 자식 컴포넌트에 useCallback을 적용하지 않은 함수를 넘겨주면 리렌더링을 유발하게 되나요?

네, 맞습니다. 부모 컴포넌트가 리렌더링 되면 함수가 재생성되고 이전과 다른 참조값을 갖게 되는데, 자식 컴포넌트가 prop으로 받는 함수의 참조가 달라졌기 때문에 얕은 비교를 하는 `React.memo`는 자식 컴포넌트를 리렌더링 시킵니다.  
[예시 코드](https://stackblitz.com/edit/stackblitz-starters-4dmbem?devToolsHeight=33&file=src%2FApp.tsx)

## ❓props와 state에 대해 설명해 주세요.

props는 부모 컴포넌트가 자식 컴포넌트로 내려주는 데이터입니다. 반면 state는 컴포넌트 내부적으로 관리하는 동적인 데이터입니다. 리액트에서 state가 변경되면 해당 컴포넌트가 다시 렌더링 됩니다.

## ❓props drilling이란 무엇인가요?

리액트는 데이터를 전달할 때 부모 컴포넌트에서 자식 컴포넌트로 props를 통해 단방향으로 전달합니다.

이러한 특성으로 인해 컴포넌트 계층이 깊어지게 되면 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하기 위해 중간에 props를 받고 넘기기만 하는 컴포넌트가 생길 수 있습니다. 이러한 현상을 props drilling 이라고 합니다.

## ❓props drilling을 해결하는 방법은 무엇인가요?

리액트에서 자체적으로 제공하는 context를 이용하여 전역으로 상태관리를 할 수 있습니다. 혹은 redux, recoil과 같은 서드파티 상태관리 라이브러리를 이용할 수도 있습니다.

## ❓zustand를 선택한 이유와 zustand의 특징에 대해 설명해 주세요.

- Zustand의 장점은 다음과 같습니다.

  - Context API에 비해 보일러 플레이트가 적기 때문에 사용하기 편리합니다.

  - Redux Devtools를 사용할 수 있어 디버깅에 용이합니다.

  - Provider가 필요 없고, 이때문에 불필요한 리렌더링을 최소화시킬 수 있습니다.

- Zustand의 특징은 다음과 같습니다.

  - MVC 패턴이 아닌 Flux 패턴을 이용합니다.

### MVC

Model, View, Controller의 약자로, Model에 데이터를 저장하고 Controller를 이용하여 Model의 데이터를 관리, Model의 데이터가 변경되면 View로 전달하여 사용자에게 보여지는 아키텍처를 말합니다. 사용자가 View를 통해 데이터를 입력하면 View 역시 Model을 업데이트할 수 있으며, 데이터가 양방향으로 흐를 수 있다는 특징을 가지고 있습니다.

### Flux

사용자 입력을 기반으로 Action을 만들고 Action을 Dispatcher에 전달하여 Store의 데이터를 변경한 뒤 View에 반영하는 단방향의 흐름으로 애플리케이션을 만드는 아키텍처를 말합니다.

## ❓Stale-While-Revalidate가 무엇인지 설명해주세요.

브라우저는 `Cache-Control` 의 `max-age` 를 기준으로 캐싱된 컨텐츠를 재사용할지 여부를 판단하게 됩니다. 이때 `stale-while-revalidate` 라는 항목을 추가로 사용함으로써 캐싱 전략을 확장할 수 있습니다.

```JSON
Cache-Control: max-age=1, stale-while-revalidate=59
```

만약 데이터가 이러한 헤더를 가지고 있다면, 브라우저는 아래와 같이 동작합니다.

1. HTTP 요청이 1초(~max-age) 이내에 반복적으로 발생했을 때
   유효성 검증 없이 캐싱된 컨텐츠를 반환합니다.

2. HTTP 요청이 1 ~ 60초(max-age ~ swr) 사이에 반복적으로 발생했을 때
   우선 캐싱된 컨텐츠를 반환하고, 이와 동시에 캐싱된 컨텐츠를 새로운 컨텐츠로 채우도록 서버에 요청합니다.

3. HTTP 요청이 60초(swr~) 이후에 발생했을 때
   요청이 서버로 바로 전달되어 새로운 컨텐츠를 반환받습니다.

## ❓virtual DOM에 대해 설명해 주세요.

Virtual DOM은 메모리상에 존재하는 가상의 DOM입니다. 일반적으로 브라우저에서 DOM의 변경이 발생하면, 브라우저는 해당 변경을 적용하고, 리플로우와 리페인트 작업을 수행합니다. 이런 방식은 DOM의 변경이 많을 때 렌더링 성능에 부정적인 영향을 미치며, 대규모 또는 복잡한 애플리케이션에서는 성능 문제가 발생할 수 있습니다.

React는 실제 DOM의 복사본인 virtual DOM 을 사용해서 상태가 변경될 때마다 Virtual DOM을 다시 생성하고 이전과 새로운 Virtual DOM을 비교하여 변경된 부분을 실제 DOM에 한번에 적용합니다. 이렇게 하면 리플로우 및 리페인트 작업의 횟수를 획기적으로 줄여서 성능을 크게 향상시킬 수 있습니다.

## ❓virtual DOM의 구조는 어떻게 이루어져 있나요?

current, workInProgress 두개의 트리가 존재합니다. current는 마운트가 끝난 트리이고, workInProgress는 업데이트가 적용 중인 트리입니다. 이러한 구조를 더블 버퍼링 이라고 하며, workInProgress 트리는 Commit Phase를 지나게 되면 Current 트리로 변경이되고, 새로운 workInProgress 트리가 생성되는 과정이 반복됩니다.

## ❓DOM과 virtual DOM의 차이점에 대해 설명해 주세요.

DOM은 현재 화면에 현재 렌더링 된 트리이며 DOM에 직접 접근할 수 있는 API를 제공합니다. 하지만 Virtual DOM은 DOM의 복사본이며 DOM에 접근할 수 없습니다. 또한 virtual DOM 자체를 직접 수정할 수도 없으며 state의 변경에 의해서만 가능합니다.

## ❓virtual DOM의 사용으로 성능이 저하될 수 있는 경우엔 무엇이 있나요?

SPA에 사용자의 인터랙션이 많고, 그에 따라 데이터가 자주 변경되는 웹페이지라면 Virtual DOM을 통해 업데이트 연산 횟수를 줄임으로써 성능을 향상시킬 수 있습니다.

하지만 React는 실제 DOM 연산에 Virtual DOM 연산이 합쳐지는 것이기 때문에, 만약 사용자의 인터랙션이 발생하지 않는 정적인 웹페이지를 렌더링할 때 Virtual DOM을 사용하는 것은 성능이 좋지 않을 수 있습니다.
