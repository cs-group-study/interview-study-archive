# Network

## ❓TCP와 UDP에 대해 설명해주세요.

TCP는 신뢰적이고 연결지향형 서비스를 제공하는 프로토콜입니다. 프로세스가 다른 프로세스에게 데이터를 보내기 전에 핸드셰이크를 함으로써 연결을 보장하며, 흐름 제어, 혼잡 제어, 오류 제어와 같은 기법으로 데이터의 신뢰적인 전송을 보장합니다.

### 흐름 제어

송신 측과 수신 측의 데이터 처리 속도를 해결하기 위한 기법으로 Stop and Wait, Sliding Window 등이 존재합니다.

- **Stop and Wait**

  매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법입니다.

- **Sliding Window**

  수신 측에서 설정한 윈도우 크기만큼, 송신측에서 확인 응답 없이 패킷을 전송할 수 있게 하여 데이터의 흐름을 동적으로 조절하는 기법입니다.

  송신 측은 윈도우에 포함된 패킷을 계속 전송하며, 이후 스신측으로부터 확인 응답이 오게 되면 윈도우를 옆으로 밀어 다음 패킷들을 전송합니다.

### 혼잡 제어

네트워크의 데이터 처리 속도를 해결하기 위한 기법으로, AIMD, Slow Start, Fast Recovery 등이 있습니다.

- **AIMD**

  패킷을 하나씩 보내고, 문제 없이 도착한다면 윈도우의 크기를 1씩 증가시켜가며 전송하는 방식입니다. 만약 전송에 실패하면 윈도우 크기를 반으로 줄입니다.

- **Slow Start**

  윈도우 크기를 선형적으로 증가시키는 AIMD와 달리, 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식입니다.

- **Fast Recovery**

  혼잡한 상태가 되면, 윈도우 크기를 1로 줄이지 않고 절반으로 줄인 뒤, 선형 증가시키는 방식입니다.
  즉, Slow Start로 윈도우 크기를 증가시키다가 혼잡을 겪으면 이후에는 절반의 윈도우 크기에서 AIMD 방식으로 동작하게 됩니다.

### 오류 제어

데이터가 유실되거나 에러가 발생하였을 때 해결하기 위한 기법으로 Stop and Wait, Go Back N 등이 있습니다.

- **Stop and Wait**

  송신측에서 1개의 데이터를 송신하고, 수신측은 해당 데이터를 정상적으로 받았다면 ACK, 받지 않았다면 NAK를 보내는 방식입니다.
  송신측이 수신측으로부터 ACK를 받았다면 다음 데이터를, NAK나 일정시간 아무런 패킷을 받지 않았다면 데이터를 재전송합니다.

- **Go Back N**

  송신측에서는 여러 데이터를 보낸 후, 전송된 데이터가 분실되거나 타임아웃이 발생한 경우, 마지막으로 확인된 데이터 이후 모든 데이터를 재전송하는 방식입니다.

UDP는 비신뢰적이고 비연결형인 서비스를 제공하는 프로토콜로, 어플리케이션이 허용되는 한, 어떤 속도로든 전송할 수 있습니다. 트랜스포트 계층 프로토콜이 할 수 있는 최소한의 기능으로 동작합니다. 그렇기 때문에 일반적인 상황에서 TCP보다 빠른 속도를 제공할 수 있다는 것이 장점입니다.

## ❓TCP보다 UDP의 속도가 더 빠른 이유는 무엇인가요?

- **연결 설정이 없기 때문입니다.**

  UDP는 TCP의 three-way handshake와 같은 공식적인 사전 준비 없이 전송하기 때문에, 연결을 설정하기 위한 어떤 지연도 없게 되어 속도가 빠릅니다.

- **작은 패킷 헤더 오버헤드를 갖고 있기 때문입니다.**

  TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 8바이트의 오버헤드를 갖기 때문에 빠른 전송이 가능합니다.

- **연결 상태가 없기 때문입니다.**

  UDP는 연결 상태를 유지하지 않으며, 연결 상태에 대한 그 어떠한 파라미터도 기록하지 않는다. 따라서 일반적으로 특정 애플리케이션 전용 서버는, 애플리케이션 프로그램이 UDP에서 동작할 때 좀 더 많은 액티브 클라이언트를 수용할 수 있어 빠른 속도를 보장합니다.

- **혼잡 제어를 하지 않기 때문입니다.**

  만약 TCP를 사용하여 라우터에 패킷 오버플로가 발생하게 되어 높은 손실률이 발생하게 된다면, TCP 송신자는 손실률을 감소시키기 위해 혼잡 제어 기법을 사용하며 데이터 전송 속도를 감소시킵니다. 그렇지만 UDP는 손실률과 상관 없이 데이터를 보내기 때문에 속도가 빠릅니다.

## ❓UDP가 활용되는 분야는 무엇인가요?

실시간으로 데이터를 빠르게 송/수신 해야할 경우 UDP를 활용해야 할 것 같습니다. 실제로 이러한 기능을 제공하는 서비스는 인터넷 전화, 온라인 게임, 멀티미디어 스트리밍 등이 있을 것 같습니다.

이외에도 성능과 연속성이 중요하면서 중요하지 않은 데이터의 손실은 감안할 수 있는 서비스라면 UDP를 활용할 수 있다고 생각합니다.

## ❓HTTP/2.0에 대해 설명해주세요.

HTTP/2는 기존의 HTTP/1.1 에서 존재했던 불편함을 개선하고자 노력을 하였으며 많은 점이 개선되었습니다.

우선 HTTP/2는 SPDY 프로토콜을 기반으로 동작하는데, 이는 기존의 HTTP에서 알려진 성능 제한을 해결하기 위해 웹 페이지의 로드 대기 시간을 줄이는 것을 목표로 구글에서 개반한 프로콜입니다.

- **이진 프로토콜**

  HTTP/1.1은 텍스트 기반 프로토콜이었기 때문에 아스키 코드로 작성되었다. 덕분에 사람이 읽기에는 편하지만 불필요하게 데이터가 커지는 문제가 있었습니다.

  HTTP/2는 보내야 할 데이터를 바이너로 변환하는 계층이 있기 때문에 단순히 텍스트를 전송하는 것 보다 훨씬 더 효율적으로 데이터를 전송할 수 있게 되었습니다.

- **응답 다중화(multiplexing)**

  HTTP/1.1은 TCP 연결에서 한 번에 하나의 요청만 처리 가능하였으나, HTTP/2 에서는 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있도록 개선하였습니다.

  이는 TCP 연결을 스트림, 메시지, 프레임이라는 단위로 세분화했기 때문입니다.

  프레이밍(framing)을 통해 HTTP 메시지를 독립된 프레임들로 쪼개고, 반대편에서 재조립할 수 있게 만들면서 동시에 많은 요청을 처리하게 되었습니다.

- **헤더 필드 압축(HPACK)**

  달라진 부분만 다시 전송하는 허프만 코딩 기법을 사용하여, 불필요하게 발생하는 오버헤드를 최소화 시켰습니다.

이 외에도 클라이언트가 요청하지 않은 리소스를 미리 클라이언트에게 보낼 수 있는 서버 푸시 기능, 스트림별 우선 순위 지정 등이 구현되었습니다.

### HTTP/1.1

기존의 HTTP/1.1은, 지속적인 연결을 사용할 때 웹 페이지당 오직 하나의 TCP 연결을 가집니다. 때문에 한번에 하나의 파일만을 보낼 수 있고, 이러한 특성으로 Head Of Line Blocking 문제가 발생할 수 있습니다.

- **Head Of Line Blocking**

  서버와 클라이언트 사이에 병목 현상이 일어나는 링크가 있다고 가정하고, 큰 비디오 파일과 수많은 작은 파일을 보낸다고 생각 해보겠습니다.

  비디오 파일이 링크를 통과하는데 오랜 시간이 걸리게 되면서, 작은 파일들이 끊임 없이 기다려야 하는 상황이 발생한다. 이런 상황에 비디오 파일이 작은 파일들을 Blocking 합니다.

이러한 문제를 해결하기 위해, HTTP/1.1 은 여러개, 최대 여섯개의 병렬 TCP 연결을 열었습니다.

- **병렬 TCP 연결**

  병렬로 TCP 연결을 하게 되면, 파일이 여러개 있는 페이지의 경우 더 빠르게 다운 받을 수 있습니다. 또한 각 연결의 지연시간을 겹치게 함으로써, 총 지연 시간을 줄일 수 있습니다.

  그렇지만 항상 병렬 TCP 연결이 빠른 것은 아닙니다. 애초에 클라이언트의 네트워크 대역폭이 좁을 경우, 데이터를 전송하고, 내려받는 시간이 느려지기 때문에 성능 상의 장점이 없어집니다.

### HTTP/3.0

HTTP/3은 HTTP/2가 TCP 위에서 동작함으로써 발생하는 근본적인 문제들을 해결하였습니다. TCP는 신뢰성을 지향하기 때문에 데이터 손실이 발생하면 재전송을 하게 되는데, 이런 과정에서 TCP 프로토콜 자체에서 HOL Blocking 문제가 발생하게 되었습니다.

또한 혼잡 제어를 수행하기 위해 전송 속도를 낮은 상태에서 천천히 높이는 방식을 사용하는데, 이는 네트워크 상황이 좋을 때 불필요한 지연을 발생시킵니다.

- **QUIC**

  이러한 문제를 해결하기 위해 QUIC 프로토콜을 도입하였습니다. 이는 TCP의 신뢰성 보장을 위해 제공되는 기능을 UDP를 기반으로 직접 구현하여 성능을 개선한 것입니다.

  UDP는 TCP와 달리 기본적으로 신뢰성을 제공하지 않는데, UDP 프로토콜 자체의 구조가 간단하기 때문에, QUIC는 신뢰성을 보장하기 위해 패킷 재전송, 혼잡 제어, 흐름 제어 기능을 직접 구현하였습니다.

  TCP는 최초 연결 수립시 three-way handshake 과정이 필요하지만, HTTP/3 은 최초 연결 설정에서 연결에 필요한 정보들과 데이터를 함께 전송하여 1 RTT로 시간을 절약합니다. 또한 한 번 성공한 연결은 캐싱해 놓은 후 바로 연결을 수립하여 0 RTT가 가능합니다.

- **연결 다중화**

  HTTP/2 또한 연결 다중화가 지원 되어 여러 스트림이 동시에 지원되지만, TCP 특성상 데이터 손실이 발생하면 HOL Blocking이 발생합니다. 하지만 QUIC 기반은 연결 스트림이 완전히 독립적으로 동작하여, 데이터 손실이 발생해도 다른 스트림에 영향을 주지 않습니다.

- **연결 별 고유 UUID**

  TCP 기반의 통신은 IP 기반으로 식별이 되었기 때문에, Wi-Fi 환경에서 셀룰러 환경으로 이동하는 경우 IP 주소가 변경되기 때문에 연결 재수립과정이 필요합니다. 그렇지만 QUIC은 연결 ID 기반이기 때문에 연결이 그대로 유지됩니다.

## ❓URL, URN, URI에 대해 설명해주세요.

URI는 Uniform Resource Identifier, 통합 자원 식별자의 줄임말로 인터넷의 자원을 식별할 수 있는 문자열을 의미하며, 하위 개념으로 URL과 URN이 있습니다.

URL은 Uniform Resource Locator의 줄임말로 네트워크 상에서 리소스가 위치한 정보를 나타냅니다. URL은 HTTP 프로토콜 뿐만 아니라 FTP, SMTP 등 다른 프로토콜에서도 사용할 수 있습니다.

URN은 Uniform Resource Name의 줄임말로 이름으로 리소스를 특정하는 URI입니다. http와 같은 프로토콜을 제외하고 리소스의 이름을 가리키는데 사용됩니다. 때문에 URN에는 리소스 접근 방법과 웹상의 위치가 표기되지 않으며, 실제 자원을 찾기 위해서는 URN을 URL로 변환하여 이용해야 합니다.

즉, URL은 어떻게 리소스를 얻을 것이고 어디에서 가져와야하는지를 명시하는 URI이고, URN은 리소스를 어떻게 접근할 것인지 명시하지 않고 경로와 리소스 자체를 특정하는 것을 목표로하는 URI입니다.

## ❓URL의 구성 요소에 대해 설명해주세요.

URL은 scheme, host, url-path, query로 나뉘어져 있는데, scheme는 사용할 프로토콜, host는 서버의 호스트명과 포트 번호, path는 서버의 경로에 대한 상세 정보, query는 접근할 대상에 전달하는 추가적인 정보를 나타냅니다.

## ❓URI의 구성 요소 중 어떤 것들이 같아야 같은 출처(same origin)이라고 할 수 있을까요?

scheme, host가 같아야 같은 출처라고 판단할 수 있습니다.

## ❓HTTP 헤더의 종류에 대해 설명해 주세요.

### General Header

공통 헤더는 요청 및 응답의 메시지 모두에서 사용되지만 **컨텐츠에는 적용되지 않는 헤더**입니다.

- Date: 요청 또는 응답이 만들어진 날짜와 시간
- Connection :현재의 전송이 완료된 후 네트워크 접속의 유지 여부
  - Keep-alive : 지속 연결
  - close : 연결 종료
- Cache-Control: 캐시 제어

### Request Header

요청 헤더는 HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더입니다. 보통 Fetch될 리소스나 클라이언트 자체에 대한 정보를 포함하여 서버로 보내집니다.

- Host: 서버의 도메인 네임과 서버가 현재 Listening 중인 TCP 포트를 알려줍니다.
- User-Agent: 사용자가 어떤 클라이언트(운영체제와 브라우저를 포함한)를 이용해 요청을 보냈는지 알려줍니다.
- Accept: 클라이언트가 받을 수 있는 응답의 타입을 서버에게 알려줍니다.
- Authorization: 서버에 인가된 사용자임을 증명할 때 사용합니다. 보통 JWT나 Bearer 토큰을 서버로 보낼 때 사용합니다.
- Origin: POST와 같은 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 알려줍니다.
- Referer

### Response Header

위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더입니다.

- Access-Control-Allow-Origin: 요청이 허용된 origin을 명시, `*`는 아무한테나 받음
- Allow
- Content-Disposition
- Location: 리다이렉트 헤더라고도 하며, 300번대 응답일 때 어느 페이지로 이동할지를 알려줍니다.
- Content-Security-Policy

### Entity Header

컨텐츠 길이나 MIME 타입과 같이 Entity Body에 대한 자세한 정보를 포함하는 헤더입니다.

- Content-Length: 바이트 단위를 가지는 Header + Body의 크기
- Content-Type: 개체의 미디어 타입(MIME)과 문자열 인코딩(UTF-8)을 지정합니다.
- Content-Language: 사용자들에게 언어를 설명하기 위해 사용됩니다. 사용자가 선호하는 언어에 따라 사용자를 구분할 수 있게 합니다.
- Content-Encoding: 미디어 타입을 압축하기 위해서 사용됩니다. ex) gzip, deflate

## ❓아래의 헤더를 통해 알 수 있는 정보는 무엇이 있을까요?

<image src='../images/response-header.png'>

- `Cache-Control`
  - no-store: 응답의 일부라도 캐싱해서는 안 되며 다른 요청을 충족하기 위해 해당 응답을 사용해서는 안 된다는 것을 나타냅니다.
  - no-cache: 유효성 검사를 통과하지 않았다면 다른 요청을 충족하는 데 해당 응답을 사용해서는 안 됨을 나타냅니다.
  - must-revalidate: 응답이 stale해지면 오리진에서 성공적으로 유효성을 검사할 때까지 캐시가 다른 요청을 충족하기 위해 해당 응답을 재사용하지 않아야 함을 나타냅니다.
  - post-check=0: 캐시된 복사본을 사용하고 0초 후 서버에서 유효성 검사를 다시 수행해야 합니다.
  - pre-check=0: 캐시된 복사본을 사용하기 0초 전 서버에서 유효성 검사를 다시 수행해야 합니다.
- `Content-Encoding`
  - gzip: 콘텐트가 gzip으로 인코딩되었음을 나타냅니다.
- `Content-Language`
  - ko-KR: 콘텐트가 한국어 사용자를 대상으로 함을 나타냅니다.
- `Content-Type`
  - text/html;charset=UTF-8: 응답 내용의 미디어 유형을 정의합니다. 여기에서는 UTF-8 문자 인코딩을 사용한 HTML입니다.
- `Date`
  - Wed, 13 Sep 2023 05:31:46 GMT: 응답이 생성된 날짜와 시간을 나타냅니다.
- `Expires`
  - Thu, 19 Nov 1981 08:52:00 GMT: 응답이 stale로 취급받아 캐싱되지 않도록 하기 위해 만료일시를 과거의 날짜로 지정했습니다.
- `Pragma`
  - no-cache: HTTP/1.0 클라이언트에 대한 이전 버전과의 호환성을 제공하고 요청-응답 체인의 모든 캐싱 메커니즘이 준수해야 하는 지시문을 지정합니다.
- `Server`
  - hide: 요청을 처리하는 서버 소프트웨어에 대한 정보를 숨깁니다.
- `Strict-Transport-Security`
  - max-age=0: 중간자 공격으로부터 웹사이트를 보호하는 데 도움이 됩니다. 이 헤더는 브라우저에 항상 HTTPS를 통해 사이트에 연결하도록 지시합니다.
- `Vary`
  - Accept-Encoding: 동일한 리소스의 여러 representation 중에서 선택하는 데 사용된 요청 헤더가 `Accept-Encoding`임을 나타냅니다.
- `X-Content-Type-Options`
  - nosniff: MIME 유형 스니핑 취약성을 완화하는 데 도움이 됩니다. 브라우저에 응답에 지정된 Content-Type을 재정의하지 않도록 지시합니다.
- `X-Frame-Options`
  - "allow-from tistory.com": 클릭재킹 방지 기능을 제공합니다. 이 경우 "tistory.com" 도메인의 콘텐츠에 대해서만 프레이밍을 허용합니다.
- `X-Ua-Compatible`
  - IE=Edge: 브라우저에 특정 버전의 Internet Explorer 렌더링 엔진을 사용하도록 지시합니다.
- `X-Xss-Protection`
  - 1: 브라우저에 내장된 크로스 사이트 스크립팅(XSS) 보호 기능을 활성화합니다.

## ❓REST API에 대해 설명해주세요.

REST는 리소스를 표현하고 상태를 전달하는 방법을 기술한 웹 아키텍처 디자인 패턴입니다.
RESTful API는 이러한 REST 원칙을 따르며, HTTP 프로토콜을 통해 데이터를 요청, 생성, 수정, 삭제하는 데 사용됩니다

**HTTP 메서드 (HTTP Methods)**
REST API에서는 HTTP 메서드를 사용하여 리소스를 다룹니다. 주요 HTTP 메서드는 다음과 같습니다.

- **GET:** 리소스를 조회하기 위해 사용됩니다.
- **POST:** 새로운 리소스를 생성하기 위해 사용됩니다.
- **PATCH:** 기존 리소스의 일부를 업데이트하기 위해 사용됩니다.
- **PUT:** 기존 리소스를 업데이트하기 위해 사용됩니다.
- **DELETE:** 리소스를 삭제하기 위해 사용됩니다.

### HTTP 주요 상태코드

**200**

GET: 리소스를 불러와서 메시지 바디에 전송되었습니다.
HEAD: 개체 해더가 메시지 바디에 있습니다.
PUT or POST: 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다.

**201**

created

리소스 생성에 성공한 응답 코드
일반적으로 Post, Put 요청 이후에 사용

**401: unauthorized**

- 인증되지 않은 사용자

**403: forbidden**

- 클라이언트가 접근할 권리 없음. 미승인

(큰 그림)
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)

[출처 MDN] https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

## ❓프록시(Proxy)에 대해 설명해주세요.

**개념**

프록시란 인터넷과 관련되어 쓰이는경우 컴퓨터 네트워크에서 중간 매개 역할을 하는 시스템 또는 라우터입니다.
클라이언트와 웹 서버 중간에 위치하여 통신을 중개하는 역할을 하며, 프록시 서버는 기본적으로 자체 IP 주소를 가지고 있는 인터넷 상의 컴퓨터입니다.

### 프록시 서버의 용도

1. 익명성 보호
   프록시를 사용하여 Client의 실제 IP 주소를 숨기고 프록시 서버의 IP 주소를 사용하여 웹서버나 다른 리소스에 접근할 수 있습니다. 이를 통해 온라인 익명성을 유지하거나 지역 제한된 콘텐츠에 접근할 수 있습니다.
2. 보안
   클라이언트와 서버 사이의 트래픽을 중개하여, 악의적인 트래픽을 필터링하고 보안 검사를 수행할 수 있습니다. 이를 통해 웹 칠터링을 통해 특정 웹 사이트에 접근을 제한할 수 있습니다.
3. 캐시
   프록시는 이전에 요청한 데이터를 저장하여 동일한 요청이 다시 들어올 때 서버로부터 데이터를 다시 가져오지 않고 저장된 데이터를 반환하여 네트워크 대역폭을 절약하고 응답 시간을 개선할 수 있습니다.
4. 접근 제어
   네트워크 접근을 제어하여 특정 웹사이트나 서버에 대한 접근을 허용/차단 할 수 있습니다. 예로 기업 네트웨크에서 특정 웹사이트를 차단하거나, 부서별로 접근을 제한하는 데에 사용할 수 있습니다.
5. 로깅과 모니터링
   로깅과 모니터링: 프록시는 클라이언트와 서버 간의 모든 트래픽을 기록하고 모니터링할 수 있으므로 네트워크 활동을 추적하고 분석하는 데 도움을 줍니다.

### Forward Proxy (정방향 프록시)와 Reverse Proxy (역방향 프록시)

프록시의 종류는 Forward Proxy, Reverse Proxy, Transparent Proxy, Anonymous Proxy, High Anonymity Proxy 등 많은 종류가 있으며
그 중에서 Forward Proxy와 Reverse Proxy에 대해 알아보겠습니다.

- Forward Proxy (정방향 프록시)
  정방향 프록시는 Client 앞에 위치하며, 내부 네트워크 내의 사용자 그룹에 데이터를 가져오는 데 사용됩니다. 요청이 전송되면 프록시 서버는 요청을 검사하여 연결을 계속 할 지 여부를 결정합니다.

  <image style="max-width:500px;" src='../images/forward-proxy.png' />

- Reverse Proxy (역방향 프록시)
  포워드 프록스(정방향 프록시)와 달리 리버스 프록시는 웹 서버 앞에 위치라여 브라우저의 요청을 웹서버로 전달합니다.
  이는 웹 서버의 네트워크 가장자리에서 사용자의 요청을 가로채는 방식으로 작동합니다. 그런 다음 원본 서버에 요청을 보내고 응답을 받습니다.

  <image style="max-width:500px;" src='../images/reverse-proxy.png' />
