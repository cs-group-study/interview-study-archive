# React

## ❓lazy initialization(게으른 초기화)에 대해 설명해 주세요.

useState에 직접적인 값 대신에 함수를 넘기는 것을 게으른(lazy) 초기화라고 합니다. 게으른 초기화 함수는 state가 처음 만들어 질 때만 실행되고 나중에 다시 리렌더링이 된다면 이 함수의 실행은 무시됩니다. 상태의 초깃값을 localStorage에서 가져오거나 map, filter, find 등 복잡한 연산으로 구해야 하는 경우에 사용합니다.

## ❓코드 스플리팅과 게으른 초기화에는 어떤 차이점이 있나요?

둘 다 최적화 기법이지만 사용법과 사용목적이 다릅니다. 코드 스플리팅은 `React.lazy(() => import('컴포넌트 경로'))`를 사용해 지금 당장 필요하지 않은 컴포넌트를 번들에 포함시키지 않고 필요한 시점에 로드하는 기법입니다. 게으른 초기화는 상태의 초깃값으로 함수를 넘겨서 상태의 최초 생성 시점에 한 번만 생성하는 기법입니다.

## ❓useLayoutEffect에 대해 설명해 주세요.

`useEffect`와 `useLayoutEffect`는 비슷하지만 실행 시점이 다릅니다. `useEffect`는 레이아웃과 페인트 이후에 실행되고 `useLayoutEffect`는 DOM이 업데이트 된 뒤에 실행됩니다. 따라서, `useEffect`를 사용하면 시각적인 깜빡임이 발생할 수 있습니다. 하지만, `useLayoutEffect`를 사용하면 화면이 그려지기 전에 작업이 처리되기 때문에, 이러한 깜빡임을 방지할 수 있습니다.

`useLayoutEffect`는

1. DOM 노드에 대한 작업이 필요한 경우
2. 브라우저의 렌더링이 완료되기 전에 작업이 처리되어야 하는 경우
3. 시각적인 깜빡임을 방지해야 하는 경우에 유용합니다.

다만, `useLayoutEffect`는 화면이 그려지기 전에 실행되기 때문에, 작업의 처리 시간이 매우 긴 경우, 사용자가 빈화면을 오랫동안 보게될 수 있으므로 주의해야 합니다.

## ❓useMemo, useCallback에 대해 설명해 주세요.

- `useMemo`는 비용이 높은 연산의 결괏값를 캐시하고, 의존성이 변경될 때만 다시 연산해서 성능을 향상시키는 데 사용됩니다. 특히 계산량이 크거나 렌더링 중에 자주 호출되는 계산의 경우에 유용합니다.
- `useCallback`은 주로 함수의 참조 안정성을 위해 사용됩니다. 함수를 컴포넌트 내에서 만들면, 해당 컴포넌트가 리렌더링될 때마다 새로운 함수가 생성되어서 참조값이 달라집니다. 이 때 `useCallback`을 사용하면 이전에 생성된 함수의 참조값을 재사용할 수 있습니다.

## ❓부모 컴포넌트에서 React.memo를 적용한 자식 컴포넌트에 useCallback을 적용하지 않은 함수를 넘겨주면 리렌더링을 유발하게 되나요?

네, 맞습니다. 부모 컴포넌트가 리렌더링 되면 함수가 재생성되고 이전과 다른 참조값을 갖게 되는데, 자식 컴포넌트가 prop으로 받는 함수의 참조가 달라졌기 때문에 얕은 비교를 하는 `React.memo`는 자식 컴포넌트를 리렌더링 시킵니다.  
[예시 코드](https://stackblitz.com/edit/stackblitz-starters-4dmbem?devToolsHeight=33&file=src%2FApp.tsx)
